# Copyright 2023 Observational Health Data Sciences and Informatics
#
# This file is part of Strategus
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Create Result Data Models
#' @description
#' Use this at the study design stage to create data models for modules
#' This functions loads modules and executes any custom code to create schemas in a results database
#' If recreate is set to TRUE all existing data will be removed, otherwise
#'
#' @inheritParams execute
#'
#' @export
createResultDataModels <- function(analysisSpecifications,
                                   executionSettings,
                                   executionScriptFolder = NULL,
                                   keyringName = NULL,
                                   restart = FALSE) {
  errorMessages <- checkmate::makeAssertCollection()
  keyringList <- keyring::keyring_list()
  checkmate::assertClass(analysisSpecifications, "AnalysisSpecifications", add = errorMessages)
  checkmate::assertClass(executionSettings, "ResultsExecutionSettings", add = errorMessages)
  checkmate::assertChoice(x = keyringName, choices = keyringList$keyring, null.ok = TRUE, add = errorMessages)
  checkmate::reportAssertions(collection = errorMessages)

  modules <- ensureAllModulesInstantiated(analysisSpecifications)


  if (is.null(executionScriptFolder)) {
    executionScriptFolder <- tempfile("strategusTempSettings")
    dir.create(executionScriptFolder)
    on.exit(unlink(executionScriptFolder, recursive = TRUE))
  } else if (!restart) {
    if (dir.exists(executionScriptFolder)) {
      unlink(executionScriptFolder, recursive = TRUE)
    }
    dir.create(executionScriptFolder, recursive = TRUE)
  }

  script <- file.path(executionScriptFolder, "SchemaScript.R")
  ##
  # Code execution inside targets block
  ##
  targets::tar_script(
    {
      ##
      # Generated by Strategus - not advisable to edit by hand
      ##
      analysisSpecificationsLoad <- readRDS(analysisSpecificationsFileName)

      targets::tar_option_set(packages = c("Strategus", "keyring"), imports = c("Strategus", "keyring"))
      targetList <- list(
        targets::tar_target(analysisSpecifications, readRDS(analysisSpecificationsFileName)),
        targets::tar_target(executionSettings, readRDS(executionSettingsFileName)),
        targets::tar_target(keyringSettings, readRDS(keyringSettingsFileName))
      )

      for (i in 1:length(analysisSpecificationsLoad$moduleSpecifications)) {
        moduleSpecification <- analysisSpecificationsLoad$moduleSpecifications[[i]]
        targetName <- sprintf("%s_%d_schema_creation", moduleSpecification$module, i)

        # Use of tar_target_raw allows dynamic names
        targetList[[length(targetList) + 1]] <- targets::tar_target_raw(targetName,
          substitute(Strategus:::runSchemaCreation(analysisSpecifications, keyringSettings, i, executionSettings),
            env = list(i = i)
          ),
          deps = c("analysisSpecifications", "keyringSettings", "executionSettings")
        )
      }
      targetList
    },
    script = script
  )

  # Store settings objects in the temp folder so they are available in targets
  analysisSpecificationsFileName <- gsub("\\\\", "/", file.path(executionScriptFolder, "analysisSpecifications.rds"))
  saveRDS(analysisSpecifications, analysisSpecificationsFileName)
  executionSettingsFileName <- gsub("\\\\", "/", file.path(executionScriptFolder, "executionSettings.rds"))
  saveRDS(executionSettings, executionSettingsFileName)
  keyringSettingsFileName <- gsub("\\\\", "/", file.path(executionScriptFolder, "keyringSettings.rds"))
  saveRDS(list(keyringName = keyringName), keyringSettingsFileName)

  # Generate target names by module type
  moduleToTargetNames <- list()
  for (i in 1:length(analysisSpecifications$moduleSpecifications)) {
    moduleSpecification <- analysisSpecifications$moduleSpecifications[[i]]
    targetName <- sprintf("%s_%d", moduleSpecification$module, i)
    moduleToTargetNames[[length(moduleToTargetNames) + 1]] <- tibble(
      module = moduleSpecification$module,
      targetName = targetName
    )
  }
  moduleToTargetNames <- bind_rows(moduleToTargetNames)
  moduleToTargetNamesFileName <- gsub("\\\\", "/", file.path(executionScriptFolder, "moduleTargetNames.rds"))
  saveRDS(moduleToTargetNames, moduleToTargetNamesFileName)

  # Settings required inside script. There is probably a much cleaner way of doing this
  writeLines(c(
    sprintf("analysisSpecificationsFileName <- '%s'", analysisSpecificationsFileName),
    sprintf("executionSettingsFileName <- '%s'", executionSettingsFileName),
    sprintf("keyringSettingsFileName <- '%s'", keyringSettingsFileName),
    sprintf("moduleToTargetNamesFileName <- '%s'", moduleToTargetNamesFileName),
    readLines(script)
  ), script)

  targets::tar_make(script = script)
}


#' Create module(s) result data model
#' @description
#' This function will create the results data model for the modules in the
#' `analysisSpecifications`. A module can implement its own results data model
#' creation function by implementing the function `createDataModelSchema` in
#' its Main.R. The default behavior is to use the `ResultsModelManager` to create
#' the results data model based on the `resultsDataModelSpecification.csv` in the
#' module's results folder.
#'
#' @template AnalysisSpecifications
#' @param keyringSettings The keyringSettings from the executionSettings context
#' @param moduleIndex The index of the module in the analysis specification
#' @template executionSettings
#' @param ... For future expansion
runSchemaCreation <- function(analysisSpecifications, keyringSettings, moduleIndex, executionSettings, ...) {
  checkmate::assert_multi_class(x = executionSettings, classes = c("ResultsExecutionSettings"))
  moduleSpecification <- analysisSpecifications$moduleSpecifications[[moduleIndex]]

  module <- moduleSpecification$module
  version <- moduleSpecification$version
  remoteRepo <- moduleSpecification$remoteRepo
  remoteUsername <- moduleSpecification$remoteUsername
  moduleFolder <- ensureModuleInstantiated(module, version, remoteRepo, remoteUsername)

  # Create job context
  moduleExecutionSettings <- executionSettings
  moduleExecutionSettings$workSubFolder <- file.path(executionSettings$workFolder, sprintf("%s_%d", module, moduleIndex))
  moduleExecutionSettings$resultsSubFolder <- file.path(executionSettings$resultsFolder, sprintf("%s_%d", module, moduleIndex))

  if (!dir.exists(moduleExecutionSettings$workSubFolder)) {
    dir.create(moduleExecutionSettings$workSubFolder, recursive = TRUE)
  }
  if (!dir.exists(moduleExecutionSettings$resultsSubFolder)) {
    dir.create(moduleExecutionSettings$resultsSubFolder, recursive = TRUE)
  }

  jobContext <- list(
    sharedResources = analysisSpecifications$sharedResources,
    settings = moduleSpecification$settings,
    moduleExecutionSettings = moduleExecutionSettings,
    keyringSettings = keyringSettings
  )
  jobContextFileName <- file.path(moduleExecutionSettings$workSubFolder, "jobContext.rds") # gsub("\\\\", "/", tempfile(fileext = ".rds"))
  saveRDS(jobContext, jobContextFileName)
  dataModelExportPath <- file.path(moduleExecutionSettings$workSubFolder, "resultsDataModelSpecification.csv")


  doneFile <- file.path(jobContext$moduleExecutionSettings$resultsSubFolder, "schema.creation")
  if (file.exists(doneFile)) {
    unlink(doneFile)
  }
  ## code executed inside renv only has scoped variables
  withModuleRenv(
    code = {
      createDataModelSchema <- NULL

      getDataModelSpecifications <- function(...) {
        if (file.exists("resultsDataModelSpecification.csv")) {
          res <- CohortGenerator::readCsv(
            file = "resultsDataModelSpecification.csv"
          )
          return(res)
        }
        return(NULL)
      }

      source("Main.R")

      jobContext <- readRDS(jobContextFileName)
      specifications <- getDataModelSpecifications(jobContext)

      if (Sys.getenv("FORCE_RENV_USE", "") == "TRUE") {
        renv::use(lockfile = "renv.lock")
      }

      ParallelLogger::addDefaultFileLogger(file.path(jobContext$moduleExecutionSettings$resultsSubFolder, "log.txt"))
      ParallelLogger::addDefaultErrorReportLogger(file.path(jobContext$moduleExecutionSettings$resultsSubFolder, "errorReportR.txt"))
      # Main.R can override default behaviour by implementing this function
      if (is.function(createDataModelSchema)) {
        # If the keyring is locked, unlock it, set the value and then re-lock it
        keyringName <- jobContext$keyringSettings$keyringName
        keyringLocked <- unlockKeyring(keyringName = keyringName)

        resultsConnectionDetails <- keyring::key_get(jobContext$moduleExecutionSettings$resultsConnectionDetailsReference, keyring = keyringName)
        resultsConnectionDetails <- ParallelLogger::convertJsonToSettings(resultsConnectionDetails)
        resultsConnectionDetails <- do.call(DatabaseConnector::createConnectionDetails, resultsConnectionDetails)
        jobContext$moduleExecutionSettings$resultsConnectionDetails <- resultsConnectionDetails

        createDataModelSchema(jobContext)

        if (keyringLocked) {
          keyring::keyring_lock(keyring = keyringName)
        }
        writeLines("schema.created", doneFile)
      } else if (is.data.frame(specifications)) {
        # Export schema to readable location
        CohortGenerator::writeCsv(
          x = specifications,
          file = dataModelExportPath,
          warnOnCaseMismatch = FALSE
        )
        writeLines("specifications.written", doneFile)
      } else {
        warning("Module does not include data specifications file or createDataModelSchema function")
        CohortGenerator::writeCsv(
          x = specifications,
          file = dataModelExportPath,
          warnOnCaseMismatch = FALSE
        )
        writeLines("specifications.not.written", doneFile)
      }

      ParallelLogger::unregisterLogger("DEFAULT_FILE_LOGGER", silent = TRUE)
      ParallelLogger::unregisterLogger("DEFAULT_ERRORREPORT_LOGGER", silent = TRUE)
    },
    moduleFolder = moduleFolder,
    tempScriptFile = file.path(moduleExecutionSettings$workSubFolder, "SchemaCreation.R"),
    injectVars = list(
      jobContextFileName = jobContextFileName,
      dataModelExportPath = dataModelExportPath,
      doneFile = doneFile
    )
  )

  workStatus <- readLines(doneFile)
  if (workStatus == "specifications.written") {
    moduleInfo <- ParallelLogger::loadSettingsFromJson(file.path(moduleFolder, "MetaData.json"))
    keyringName <- jobContext$keyringSettings$keyringName
    keyringLocked <- Strategus::unlockKeyring(keyringName = keyringName)

    resultsConnectionDetails <- keyring::key_get(jobContext$moduleExecutionSettings$resultsConnectionDetailsReference, keyring = keyringName)
    resultsConnectionDetails <- ParallelLogger::convertJsonToSettings(resultsConnectionDetails)
    resultsConnectionDetails <- do.call(DatabaseConnector::createConnectionDetails, resultsConnectionDetails)

    connection <- DatabaseConnector::connect(resultsConnectionDetails)
    on.exit(DatabaseConnector::disconnect(connection))

    sql <- ResultModelManager::generateSqlSchema(csvFilepath = dataModelExportPath)
    DatabaseConnector::renderTranslateExecuteSql(connection,
      sql,
      table_prefix = moduleInfo$TablePrefix,
      database_schema = jobContext$moduleExecutionSettings$resultsDatabaseSchema
    )

    if (keyringLocked) {
      keyring::keyring_lock(keyring = keyringName)
    }
  } else if (workStatus == "schema.created") {
    message("Result schema creation handled inside module execution envrionment")
  } else {
    message("Schema not created for module")
  }

  return(list(dummy = 123))
}
